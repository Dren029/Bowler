<!doctype html>
<html lang="en">
<head>
	<meta charset="utf-8" />
	<meta name="viewport" content="width=device-width,initial-scale=1" />
	<title>Plane Chaos</title>
	<style>
		html,body{height:100%;margin:0;background:linear-gradient(135deg, #000000 0%, #001a4d 50%, #000066 100%);color:#ffff99;font-family:'Courier New',monospace;overflow:hidden}
		#game{display:block;margin:0 auto;background:linear-gradient(180deg, #0066cc 0%, #003366 100%);box-shadow:0 0 40px rgba(0,100,255,.5), 0 15px 50px rgba(0,0,0,.9), inset 0 0 60px rgba(0,50,100,.3);border:4px solid #ffff00;position:relative;top:50%;transform:translateY(-50%);margin-top:0;image-rendering:pixelated;image-rendering:crisp-edges}
		.ui{position:fixed;left:20px;top:20px;font-weight:900;font-size:20px;display:flex;gap:40px;background:rgba(0,20,60,.9);padding:18px 28px;border:4px solid #ffff00;box-shadow:0 0 20px rgba(255,255,0,.4), inset 0 0 10px rgba(255,255,0,.2);font-family:'Courier New',monospace;letter-spacing:2px}
		.ui .score{color:#ffff00}
		.ui .lives{color:#ff3333}
		.ui span{display:flex;align-items:center;gap:10px}
		#overlay{position:fixed;inset:0;display:flex;align-items:center;justify-content:center;background:rgba(0,0,0,.85);backdrop-filter:blur(2px);z-index:1000;animation:fadeIn 0.3s ease-out}
		@keyframes fadeIn{from{opacity:0;backdrop-filter:blur(0)} to{opacity:1;backdrop-filter:blur(2px)}}
		#panel{background:linear-gradient(135deg, #000033 0%, #001166 100%);padding:40px 50px;border:6px solid #ffff00;text-align:center;box-shadow:0 20px 60px rgba(0,0,0,.9),inset 0 2px 2px rgba(255,255,0,.3);animation:slideIn 0.4s cubic-bezier(0.23,1,0.320,1);max-width:550px}
		@keyframes slideIn{from{opacity:0;transform:translateY(-30px)} to{opacity:1;transform:translateY(0)}}
		#panel h1{margin:0 0 16px;font-size:42px;color:#ffff00;text-shadow:0 0 10px #ffff00, 0 0 20px #ff6600, 2px 2px 0px #ff3333;font-family:'Courier New',monospace;font-weight:900;letter-spacing:3px}
		#panel h2{margin:0 0 12px;font-size:24px;color:#ff6600;text-shadow:0 0 8px #ff6600}
		#panel p{margin:0 0 20px;font-size:16px;color:#ffff99;line-height:1.8;text-shadow:0 0 5px rgba(255,255,0,.3)}
		button{background:linear-gradient(135deg, #ffff00 0%, #ffcc00 100%);border:4px solid #ff3333;padding:16px 36px;color:#000033;font-weight:900;cursor:pointer;font-size:18px;transition:all 0.3s ease;box-shadow:0 6px 0px #ff3333, 0 10px 20px rgba(0,0,0,.5);position:relative;overflow:hidden;font-family:'Courier New',monospace;letter-spacing:2px;text-transform:uppercase}
		button:hover{transform:translateY(-2px);box-shadow:0 8px 0px #ff3333, 0 12px 25px rgba(255,255,0,.4);background:linear-gradient(135deg, #ffff99 0%, #ffdd00 100%)}
		button:active{transform:translateY(2px);box-shadow:0 2px 0px #ff3333, 0 4px 10px rgba(0,0,0,.5)}
		small{display:block;margin-top:16px;color:#ffcc00;font-size:14px;font-style:italic;text-shadow:0 0 5px rgba(255,204,0,.3)}
		@media (max-width:600px){#game{width:calc(100% - 20px);height:auto;max-height:70vh}}
	</style>
</head>
<body>
	<div class="ui">
		<span class="score">SCORE: <span id="score">0</span></span>
		<span class="lives">HEALTH: <span id="lives">3</span></span>
	</div>

	<canvas id="game" width="900" height="600"></canvas>

	<div id="overlay">
		<div id="panel">
			<h1>PLANE CHAOS</h1>
			<h2>A PLANE SHOOTER</h2>
			<p>DEFEND THE SKIES! Pilot your fighter jet and destroy enemy aircraft. Use ARROW KEYS or MOUSE to move, SPACE or CLICK to fire!</p>
			<button id="startBtn">START MISSION</button>
			<small>Defeat all enemy waves — Stay alive!</small>
		</div>
	</div>

	<script>
	// Plane Chaos: with 8-bit detailed graphics
	const canvas = document.getElementById('game');
	const ctx = canvas.getContext('2d');
	let W = canvas.width, H = canvas.height;

		const state = {
		running:false,
		player: {x: W/2, y: H-70, w:28, h:40, speed:200}, // fighter jet
		bullets: [],
		enemyBullets: [],
		enemies: [], // enemy planes
		particles: [],
		powerups: [],
		score: 0,
		lives: 3,
		spawnTimer: 0,
		spawnInterval: 5000,
		lastShot: 0,
		fireRate: 11, // bullets/sec
		wave: 1,
		waveTimer: 0,
		waveDuration: 15000, // ms per wave
		boss: null,
		enemyDirection: 1,
		spawnWaveActive: true,
		spawnWaveTimer: 0,
		spawnWaveDuration: 4000,
		spawnBreakDuration: 5000,
		rapidFireActive: false,
		rapidFireTimer: 0,
		shieldActive: false,
		multiShotActive: false,
		multiShotTimer: 0,
		originalFireRate: 11
	};

	// Audio
	let audioCtx = null;
	function ensureAudio(){ if(!audioCtx){ audioCtx = new (window.AudioContext||window.webkitAudioContext)(); }}
	function playBeep(freq=600, type='square', time=0.06, gain=0.12){ 
		try{ 
			ensureAudio(); 
			const o=audioCtx.createOscillator(); 
			const g=audioCtx.createGain(); 
			o.type=type; 
			o.frequency.value=freq;
			g.gain.setValueAtTime(gain, audioCtx.currentTime);
			g.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + time);
			o.connect(g); 
			g.connect(audioCtx.destination); 
			o.start(); 
			o.stop(audioCtx.currentTime + time); 
		}catch(e){} 
	}
	function playShoot(){ playBeep(1400,'square',0.05,0.15); playBeep(1100,'square',0.04,0.1); }
	function playHit(){ playBeep(250,'square',0.06,0.2); playBeep(350,'square',0.05,0.15); }
	function playWaveUp(){ playBeep(1800,'square',0.08,0.12); playBeep(2200,'square',0.1,0.12); playBeep(1400,'square',0.06,0.1); }
	function playPowerUp(){ playBeep(700,'square',0.08,0.15); playBeep(1000,'square',0.06,0.15); playBeep(1300,'square',0.08,0.15); }

	// Helpers
	function rand(min,max){return Math.random()*(max-min)+min}
	function clamp(v,a,b){return Math.max(a,Math.min(b,v))}

	// Input
	const keys = {};
	window.addEventListener('keydown', e=>{keys[e.code]=true; if(e.code==='Space'){e.preventDefault(); shoot()} });
	window.addEventListener('keyup', e=>{keys[e.code]=false});
	canvas.addEventListener('mousemove', e=>{
		const r = canvas.getBoundingClientRect();
		const mx = (e.clientX - r.left) * (canvas.width / r.width);
		const dpr = window.devicePixelRatio || 1;
		state.player.x = clamp(mx / dpr, state.player.w/2, W - state.player.w/2);
	});
	canvas.addEventListener('click', ()=>{ ensureAudio(); shoot(); });
	canvas.addEventListener('touchmove', e=>{ e.preventDefault(); const t=e.touches[0]; const r = canvas.getBoundingClientRect(); const mx = (t.clientX - r.left) * (canvas.width / r.width); const dpr = window.devicePixelRatio || 1; state.player.x = clamp(mx / dpr, state.player.w/2, W - state.player.w/2); }, {passive:false});
	canvas.addEventListener('touchstart', e=>{ e.preventDefault(); ensureAudio(); shoot(); }, {passive:false});

	// Shooting
	function shoot(){
		if(!state.running) return;
		const now = performance.now();
		const minInterval = 1000 / state.fireRate;
		if(now - state.lastShot < minInterval) return;
		state.lastShot = now;
		
		if(state.multiShotActive) {
			state.bullets.push({x: state.player.x - 8, y: state.player.y-20, r:3, speed: 500});
			state.bullets.push({x: state.player.x, y: state.player.y-20, r:3, speed: 500});
			state.bullets.push({x: state.player.x + 8, y: state.player.y-20, r:3, speed: 500});
		} else {
			state.bullets.push({x: state.player.x, y: state.player.y-20, r:3, speed: 500});
		}
		playShoot();
	}

	// Particles
	function spawnParticles(x,y,color,count=12){
		for(let i=0;i<count;i++){
			state.particles.push({x,y,vx:rand(-200,200),vy:rand(-300,-80),life:rand(400,900),age:0,color});
		}
	}

	// Spawn enemy planes
	function spawnEnemy(x, type){
		if(!x) x = rand(30, W-30);
		if(!type) type = 'fighter';
		
		let w = 20, h = 20;
		let health = 1;
		let speed = 80;
		let color = '#ff3333';
		
		if(type === 'fast') {
			w = 18; h = 16;
			speed = 120;
			color = '#ff66ff';
		} else if(type === 'heavy') {
			w = 28; h = 26;
			health = 2;
			speed = 50;
			color = '#ff8800';
		} else if(type === 'bomber') {
			w = 32; h = 20;
			health = 3;
			speed = 40;
			color = '#ccaa00';
		}
		
		state.enemies.push({x, y: 30, vx: 0, vy: speed, w, h, type, health, maxHealth: health, color, shootTimer: rand(800, 1500)});
	}
	
	// Spawn waves
	function spawnWaveFormation(){
		const wavePattern = state.wave % 5;
		
		if(wavePattern === 0) {
			spawnEnemyRow(2, 3, 50);
		} else if(wavePattern === 1) {
			spawnEnemyRow(3, 4, 45);
		} else if(wavePattern === 2) {
			spawnEnemyRow(2, 5, 55);
		} else if(wavePattern === 3) {
			spawnEnemyRow(3, 4, 50);
		} else {
			spawnEnemyRow(3, 5, 48);
		}
	}
	
	function spawnEnemyRow(numRows, perRow, rowSpacing){
		const startY = 40;
		
		for(let row = 0; row < numRows; row++) {
			const yPos = startY + row * rowSpacing;
			const totalWidth = perRow * 50;
			const startX = (W - totalWidth) / 2;
			
			for(let col = 0; col < perRow; col++) {
				const xPos = startX + col * 50 + 25;
				let type = 'fighter';
				if(Math.random() < 0.15) type = 'fast';
				if(Math.random() < 0.1) type = 'heavy';
				spawnEnemy(xPos, type);
			}
		}
	}
	
	// Advance waves
	function advanceWave(){
		state.wave += 1;
		state.waveTimer = 0;
		state.spawnInterval = Math.max(500, state.spawnInterval - 60);
		playWaveUp();
		
		if(state.wave % 4 === 0) {
			state.boss = {
				x: W/2, y: -60, vx: 0, vy: 40, w: 50, h: 40, type: 'boss',
				health: 15, maxHealth: 15, color: '#ffff00',
				shootTimer: 300, pattern: 0
			};
		}
	}

	// Power-ups
	function spawnPowerUp(x, y){
		const types = ['rapidFire', 'shield', 'multiShot'];
		const type = types[Math.floor(Math.random() * types.length)];
		state.powerups.push({x, y, vx: rand(-50, 50), vy: -100, type, size: 14, rotation: 0});
	}
	
	function applyPowerUp(powerup){
		playPowerUp();
		if(powerup.type === 'rapidFire') {
			state.rapidFireActive = true;
			state.rapidFireTimer = 6000;
			state.fireRate = 20;
		} else if(powerup.type === 'shield') {
			state.lives = Math.min(state.lives + 1, 8);
			document.getElementById('lives').textContent = state.lives;
		} else if(powerup.type === 'multiShot') {
			state.multiShotActive = true;
			state.multiShotTimer = 8000;
		}
	}

	// Update
	function update(dt){
		const dtSec = dt/1000;
		if(!state.running) return;
		
		if(state.enemies.length === 0 && !state.boss && state.wave > 0) {
			advanceWave();
		}

		if(state.rapidFireActive) {
			state.rapidFireTimer -= dt;
			if(state.rapidFireTimer <= 0) {
				state.rapidFireActive = false;
				state.fireRate = state.originalFireRate;
			}
		}
		if(state.multiShotActive) {
			state.multiShotTimer -= dt;
			if(state.multiShotTimer <= 0) {
				state.multiShotActive = false;
			}
		}

		// Boss update
		if(state.boss) {
			state.boss.y += state.boss.vy * dtSec;
			state.boss.x += Math.sin(performance.now() * 0.001) * 60 * dtSec;
			state.boss.x = clamp(state.boss.x, state.boss.w/2, W - state.boss.w/2);
			
			if(state.boss.y + state.boss.h/2 > state.player.y - 10){
				spawnParticles(state.boss.x, state.player.y, '#ff6b6b', 40);
				state.boss = null;
				state.lives -= 3;
				document.getElementById('lives').textContent = state.lives;
				if(state.lives <= 0) gameOver();
			}
			
			for(let j=state.bullets.length-1;j>=0;j--){
				const b = state.bullets[j];
				const dx = b.x - state.boss.x, dy = b.y - state.boss.y;
				if(dx*dx + dy*dy < (b.r + state.boss.w/2)*(b.r + state.boss.w/2)){
					state.bullets.splice(j,1);
					state.boss.health -= 1;
					spawnParticles(b.x, b.y, '#ff6600', 10);
					if(state.boss.health <= 0) {
						state.score += 800;
						document.getElementById('score').textContent = state.score;
						spawnParticles(state.boss.x, state.boss.y, '#ffff00', 50);
						playHit();
						for(let i = 0; i < 3; i++) {
							spawnPowerUp(state.boss.x + rand(-40, 40), state.boss.y);
						}
						state.boss = null;
					}
				}
			}
		}

		// Player movement
		if(keys['ArrowLeft']||keys['KeyA']) state.player.x -= state.player.speed * dtSec;
		if(keys['ArrowRight']||keys['KeyD']) state.player.x += state.player.speed * dtSec;
		state.player.x = clamp(state.player.x, state.player.w/2, W - state.player.w/2);

		// Bullets
		for(let i=state.bullets.length-1;i>=0;i--){
			const b = state.bullets[i];
			b.y -= b.speed * dtSec;
			if(b.y < -20) state.bullets.splice(i,1);
		}

		// Enemy bullets
		for(let i=state.enemyBullets.length-1;i>=0;i--){
			const b = state.enemyBullets[i];
			b.y += b.speed * dtSec;
			if(b.y > H) {
				state.enemyBullets.splice(i,1);
				continue;
			}
			
			const dx = b.x - state.player.x;
			const dy = b.y - state.player.y;
			if(dx*dx + dy*dy < (b.r + state.player.w/2)*(b.r + state.player.w/2)){
				state.enemyBullets.splice(i,1);
				state.lives -= 1;
				document.getElementById('lives').textContent = state.lives;
				spawnParticles(b.x, b.y, '#ff3333', 12);
				if(state.lives <= 0) gameOver();
			}
		}

		// Power-ups
		for(let i=state.powerups.length-1;i>=0;i--){
			const p = state.powerups[i];
			p.vy += 600 * dtSec;
			p.x += p.vx * dtSec;
			p.y += p.vy * dtSec;
			p.rotation += dtSec * 5;
			
			if(p.y > H) {
				state.powerups.splice(i,1);
				continue;
			}
			
			const dx = p.x - state.player.x;
			const dy = p.y - state.player.y;
			if(dx*dx + dy*dy < (p.size + state.player.w/2)*(p.size + state.player.w/2)){
				applyPowerUp(p);
				spawnParticles(p.x, p.y, '#00ff00', 15);
				state.powerups.splice(i,1);
			}
		}

		// Enemies
		for(let i=state.enemies.length-1;i>=0;i--){
			const e = state.enemies[i];
			e.y += e.vy * dtSec;
			
			if(e.y + e.h/2 > state.player.y - 10){
				spawnParticles(e.x, state.player.y, '#ff6b6b', 20);
				state.enemies.splice(i,1);
				state.lives -= 1;
				document.getElementById('lives').textContent = state.lives;
				if(state.lives <= 0) gameOver();
				continue;
			}
			
			for(let j=state.bullets.length-1;j>=0;j--){
				const b = state.bullets[j];
				const dx = b.x - e.x, dy = b.y - e.y;
				if(dx*dx + dy*dy < (b.r + e.w/2)*(b.r + e.w/2)){
					state.bullets.splice(j,1);
					e.health -= 1;
					
					if(e.health <= 0) {
						state.enemies.splice(i,1);
						state.score += Math.round(50 + e.w + state.wave*5 + (e.maxHealth-1)*25);
						document.getElementById('score').textContent = state.score;
						spawnParticles(e.x, e.y, e.color, 20);
						playHit();
						if(Math.random() < 0.2) {
							spawnPowerUp(e.x, e.y);
						}
					} else {
						spawnParticles(e.x, e.y, e.color, 8);
					}
					break;
				}
			}
		}

		// Particles
		for(let i=state.particles.length-1;i>=0;i--){
			const p = state.particles[i];
			p.age += dt;
			p.vy += 800 * dtSec;
			p.x += p.vx * dtSec;
			p.y += p.vy * dtSec;
			if(p.age >= p.life) state.particles.splice(i,1);
		}

		// Spawn logic
		state.spawnWaveTimer += dt;
		
		if(state.spawnWaveActive) {
			if(state.spawnWaveTimer > state.spawnWaveDuration) {
				state.spawnWaveTimer = 0;
				state.spawnWaveActive = false;
			}
		} else {
			if(state.spawnWaveTimer > state.spawnBreakDuration) {
				state.spawnWaveTimer = 0;
				state.spawnWaveActive = true;
			}
		}
		
		if(state.spawnWaveActive) {
			state.spawnTimer += dt;
			const spawnFactor = Math.min(1.4, 0.8 + (state.wave-1)*0.025);
			if(state.spawnTimer > state.spawnInterval * spawnFactor){
				state.spawnTimer = 0;
				spawnWaveFormation();
			}
		}
		
		// Enemy shooting
		for(let i=state.enemies.length-1;i>=0;i--){
			const e = state.enemies[i];
			e.shootTimer -= dt;
			if(e.shootTimer <= 0) {
				if(Math.random() < 0.5) {
					state.enemyBullets.push({x: e.x, y: e.y + e.h/2, r: 3, speed: 350});
				}
				e.shootTimer = rand(1000, 2500);
			}
		}
	}

	// Draw helpers
	function drawPlayer(){
		const p = state.player;
		ctx.save();
		ctx.translate(p.x, p.y);
		
		// 8-bit fighter jet cockpit window
		ctx.fillStyle = '#ffff00';
		ctx.fillRect(-3, -18, 6, 6);
		ctx.fillStyle = '#0066ff';
		ctx.fillRect(-2, -17, 4, 4);
		
		// Jet body - pixel art fuselage
		ctx.fillStyle = '#00ff00';
		ctx.fillRect(-4, -14, 8, 24);
		ctx.fillStyle = '#00cc00';
		ctx.fillRect(-3, -12, 6, 20);
		
		// Wings
		ctx.fillStyle = '#00ff00';
		ctx.fillRect(-12, -2, 10, 4);
		ctx.fillRect(2, -2, 10, 4);
		ctx.fillStyle = '#00cc00';
		ctx.fillRect(-10, 0, 8, 2);
		ctx.fillRect(2, 0, 8, 2);
		
		// Tail fins
		ctx.fillStyle = '#ffaa00';
		ctx.fillRect(-2, 8, 4, 8);
		ctx.fillStyle = '#ff8800';
		ctx.fillRect(-1, 10, 2, 6);
		
		// Engine glow
		ctx.fillStyle = 'rgba(255,255,0,0.6)';
		ctx.fillRect(-3, 14, 6, 3);
		
		ctx.restore();
	}

	function drawBullet(b){
		ctx.save();
		ctx.fillStyle = '#ffff00';
		ctx.fillRect(b.x - 2, b.y - 6, 4, 10);
		ctx.fillStyle = '#ffff99';
		ctx.fillRect(b.x - 1, b.y - 4, 2, 6);
		ctx.restore();
	}
	
	function drawEnemyBullet(b){
		ctx.save();
		ctx.fillStyle = '#ff6b6b';
		ctx.fillRect(b.x - 2, b.y - 6, 4, 10);
		ctx.fillStyle = '#ff9999';
		ctx.fillRect(b.x - 1, b.y - 4, 2, 6);
		ctx.restore();
	}

	function drawEnemy(e){
		ctx.save();
		ctx.translate(e.x, e.y);
		
		const colorMap = {
			'fighter': ['#ff3333', '#cc0000'],
			'fast': ['#ff66ff', '#dd00dd'],
			'heavy': ['#ff8800', '#dd6600'],
			'bomber': ['#ccaa00', '#aa8800']
		};
		
		const [mainColor, darkColor] = colorMap[e.type] || colorMap['fighter'];
		
		// Fuselage
		ctx.fillStyle = mainColor;
		ctx.fillRect(-e.w/2, -e.h*0.3, e.w, e.h*0.4);
		ctx.fillStyle = darkColor;
		ctx.fillRect(-e.w/2 + 1, -e.h*0.25, e.w - 2, 2);
		
		// Cockpit
		ctx.fillStyle = '#ffff00';
		ctx.fillRect(-e.w*0.15, -e.h*0.25, e.w*0.3, 3);
		ctx.fillStyle = '#0066ff';
		ctx.fillRect(-e.w*0.12, -e.h*0.22, e.w*0.24, 2);
		
		// Wings
		ctx.fillStyle = mainColor;
		ctx.fillRect(-e.w*0.8, e.h*0.05, e.w*0.3, e.h*0.15);
		ctx.fillRect(e.w*0.5, e.h*0.05, e.w*0.3, e.h*0.15);
		ctx.fillStyle = darkColor;
		ctx.fillRect(-e.w*0.75, e.h*0.07, e.w*0.25, 1);
		ctx.fillRect(e.w*0.5, e.h*0.07, e.w*0.25, 1);
		
		// Tail
		ctx.fillStyle = darkColor;
		ctx.fillRect(-2, e.h*0.3, 4, e.h*0.25);
		ctx.fillStyle = mainColor;
		ctx.fillRect(-1, e.h*0.35, 2, e.h*0.2);
		
		// Health indicator
		if(e.health > 1) {
			ctx.fillStyle = '#ffff00';
			ctx.font = 'bold ' + Math.max(8, e.w*0.3) + 'px Arial';
			ctx.textAlign = 'center';
			ctx.fillText(e.health, 0, -e.h*0.5);
		}
		
		ctx.restore();
	}
	
	function drawBossFighter(b){
		ctx.save();
		ctx.translate(b.x, b.y);
		
		const w = b.w / 2;
		
		// Main fuselage
		ctx.fillStyle = '#ffff00';
		ctx.fillRect(-w*1.3, -b.h*0.3, w*2.6, b.h*0.45);
		ctx.fillStyle = '#ccaa00';
		ctx.fillRect(-w*1.2, -b.h*0.25, w*2.4, 3);
		
		// Cockpit
		ctx.fillStyle = '#ff0000';
		ctx.fillRect(-w*0.5, -b.h*0.3, w, 4);
		ctx.fillStyle = '#ff6600';
		ctx.fillRect(-w*0.4, -b.h*0.26, w*0.8, 2);
		
		// Large wings
		ctx.fillStyle = '#ffff00';
		ctx.fillRect(-w*1.6, b.h*0.05, w*0.8, b.h*0.2);
		ctx.fillRect(w*0.8, b.h*0.05, w*0.8, b.h*0.2);
		ctx.fillStyle = '#ccaa00';
		ctx.fillRect(-w*1.55, b.h*0.08, w*0.75, 2);
		ctx.fillRect(w*0.8, b.h*0.08, w*0.75, 2);
		
		// Twin tails
		ctx.fillStyle = '#ff3333';
		ctx.fillRect(-w*0.8, b.h*0.35, w*0.4, b.h*0.35);
		ctx.fillRect(w*0.4, b.h*0.35, w*0.4, b.h*0.35);
		ctx.fillStyle = '#ff6600';
		ctx.fillRect(-w*0.75, b.h*0.4, w*0.3, b.h*0.25);
		ctx.fillRect(w*0.45, b.h*0.4, w*0.3, b.h*0.25);
		
		// Health bar
		const barWidth = w*2;
		const barHeight = 10;
		ctx.fillStyle = '#000';
		ctx.fillRect(-w, b.h*0.55, barWidth, barHeight);
		ctx.strokeStyle = '#ffff00';
		ctx.lineWidth = 2;
		ctx.strokeRect(-w, b.h*0.55, barWidth, barHeight);
		
		const healthPercent = b.health / b.maxHealth;
		ctx.fillStyle = '#00ff00';
		ctx.fillRect(-w + 2, b.h*0.55 + 2, (barWidth - 4) * healthPercent, barHeight - 4);
		
		ctx.restore();
	}
	
	function drawPowerUp(p) {
		ctx.save();
		ctx.translate(p.x, p.y);
		ctx.rotate(p.rotation);
		
		const colors = {
			rapidFire: '#ff9500',
			shield: '#00ff00',
			multiShot: '#ff66ff'
		};
		
		const color = colors[p.type] || '#fff';
		ctx.fillStyle = color;
		
		if(p.type === 'rapidFire') {
			ctx.fillRect(-3, -p.size, 2, p.size*2);
			ctx.fillRect(1, -p.size, 2, p.size*2);
		} else if(p.type === 'shield') {
			ctx.fillRect(-p.size, -p.size, p.size*2, p.size*1.5);
			ctx.fillStyle = color;
			ctx.globalAlpha = 0.5;
			ctx.fillRect(-p.size + 2, -p.size + 2, p.size*2 - 4, p.size*1.5 - 4);
			ctx.globalAlpha = 1;
		} else if(p.type === 'multiShot') {
			ctx.fillRect(-5, -p.size, 2, p.size*2);
			ctx.fillRect(1, -p.size, 2, p.size*2);
			ctx.fillRect(7, -p.size, 2, p.size*2);
		}
		
		ctx.restore();
	}

	function drawParticle(p){
		const t = 1 - (p.age / p.life);
		ctx.fillStyle = p.color;
		ctx.globalAlpha = Math.max(0, t);
		ctx.fillRect(p.x-2, p.y-2, 4, 4);
		ctx.globalAlpha = 1;
	}

	function render(){
		// Sky background - aerial view
		const bgGrad = ctx.createLinearGradient(0, 0, 0, H);
		bgGrad.addColorStop(0, '#0066ff');
		bgGrad.addColorStop(0.5, '#0099ff');
		bgGrad.addColorStop(1, '#0033aa');
		ctx.fillStyle = bgGrad;
		ctx.fillRect(0, 0, W, H);
		
		// Cloud-like scanline effect
		ctx.strokeStyle = 'rgba(255, 255, 255, 0.08)';
		ctx.lineWidth = 1;
		for(let y = 0; y < H; y += 3) {
			ctx.beginPath();
			ctx.moveTo(0, y);
			ctx.lineTo(W, y);
			ctx.stroke();
		}
		
		// Grid pattern for retro style
		ctx.strokeStyle = 'rgba(0, 255, 255, 0.05)';
		ctx.lineWidth = 1;
		for(let x = 0; x < W; x += 40) {
			ctx.beginPath();
			ctx.moveTo(x, 0);
			ctx.lineTo(x, H);
			ctx.stroke();
		}
		
		// Enemies
		for(const e of state.enemies) drawEnemy(e);
		
		// Boss
		if(state.boss) drawBossFighter(state.boss);
		
		// Bullets
		for(const b of state.bullets) drawBullet(b);
		for(const b of state.enemyBullets) drawEnemyBullet(b);
		
		// Power-ups
		for(const p of state.powerups) drawPowerUp(p);
		
		// Particles
		for(const p of state.particles) drawParticle(p);
		
		// Player
		drawPlayer();
		
		// Status indicators
		let statusX = W - 200;
		if(state.rapidFireActive) {
			ctx.fillStyle = '#ff9500';
			ctx.strokeStyle = '#ffff00';
			ctx.lineWidth = 3;
			ctx.fillRect(statusX, 12, 185, 36);
			ctx.strokeRect(statusX, 12, 185, 36);
			ctx.fillStyle = '#000';
			ctx.font = 'bold 14px Courier';
			ctx.fillText('RAPID FIRE ' + Math.ceil(state.rapidFireTimer/1000) + 's', statusX+8, 36);
			statusX -= 195;
		}
		if(state.multiShotActive) {
			ctx.fillStyle = '#ff66ff';
			ctx.strokeStyle = '#ffff00';
			ctx.lineWidth = 3;
			ctx.fillRect(statusX, 12, 185, 36);
			ctx.strokeRect(statusX, 12, 185, 36);
			ctx.fillStyle = '#000';
			ctx.font = 'bold 14px Courier';
			ctx.fillText('MULTI-SHOT ' + Math.ceil(state.multiShotTimer/1000) + 's', statusX+8, 36);
		}
		
		// Boss indicator
		if(state.boss) {
			ctx.fillStyle = '#ffff00';
			ctx.strokeStyle = '#ff3333';
			ctx.lineWidth = 4;
			ctx.fillRect(W/2 - 120, 12, 240, 45);
			ctx.strokeRect(W/2 - 120, 12, 240, 45);
			ctx.fillStyle = '#000';
			ctx.font = 'bold 16px Courier';
			ctx.textAlign = 'center';
			ctx.fillText('BOSS AIRCRAFT - HP: ' + state.boss.health + '/' + state.boss.maxHealth, W/2, 40);
			ctx.textAlign = 'left';
		}
		
		// Wave incoming indicator
		if(!state.spawnWaveActive) {
			ctx.fillStyle = '#00ff00';
			ctx.strokeStyle = '#ffff00';
			ctx.lineWidth = 3;
			ctx.fillRect(W/2 - 140, 65, 280, 35);
			ctx.strokeRect(W/2 - 140, 65, 280, 35);
			ctx.fillStyle = '#000';
			ctx.font = 'bold 14px Courier';
			ctx.textAlign = 'center';
			ctx.fillText('INCOMING WAVE IN ' + Math.ceil((state.spawnBreakDuration - state.spawnWaveTimer)/1000) + 's', W/2, 90);
			ctx.textAlign = 'left';
		}
		
		// HUD: wave indicator
		ctx.fillStyle = '#ffff00';
		ctx.strokeStyle = '#ff3333';
		ctx.lineWidth = 3;
		ctx.fillRect(12, H-55, 160, 43);
		ctx.strokeRect(12, H-55, 160, 43);
		ctx.fillStyle = '#000';
		ctx.font = 'bold 18px Courier';
		ctx.fillText('WAVE ' + state.wave, 28, H-26);
	}

	// Game loop
	let last = performance.now();
	function loop(t){
		const dt = t - last; last = t;
		update(dt);
		render();
		requestAnimationFrame(loop);
	}

	// Resize handling
	function fitCanvas(){
		const ratio = 900/600;
		const maxW = Math.min(window.innerWidth-20, 1100);
		const cssW = Math.max(380, Math.min(maxW, window.innerWidth-40));
		const cssH = Math.round(cssW / ratio);
		const dpr = Math.max(1, window.devicePixelRatio || 1);
		canvas.style.width = cssW + 'px';
		canvas.style.height = cssH + 'px';
		canvas.width = Math.round(cssW * dpr);
		canvas.height = Math.round(cssH * dpr);
		ctx.setTransform(dpr,0,0,dpr,0,0);
		W = cssW; H = cssH;
		state.player.y = H - 70;
	}
	window.addEventListener('resize', fitCanvas);
	fitCanvas();

	// Game control
	function startGame(){
		ensureAudio();
		state.running = true;
		state.score = 0; state.lives = 3;
		state.bullets = []; state.enemyBullets = []; state.enemies = []; state.particles = []; state.powerups = [];
		state.spawnTimer = 0; state.spawnInterval = 5000; state.lastShot = 0; state.wave = 1; state.waveTimer = 0;
		state.rapidFireActive = false; state.rapidFireTimer = 0;
		state.multiShotActive = false; state.multiShotTimer = 0;
		state.fireRate = state.originalFireRate;
		state.spawnWaveActive = true;
		state.spawnWaveTimer = 0;
		state.boss = null;
		document.getElementById('score').textContent = state.score;
		document.getElementById('lives').textContent = state.lives;
		document.getElementById('overlay').style.display = 'none';
	}
	function setPanelDefault(){
		const panel = document.getElementById('panel');
		panel.innerHTML = `<h1>PLANE CHAOS</h1><h2>PLANE SHOOTER</h2><p>DEFEND THE SKIES! Pilot your fighter jet and destroy enemy aircraft. Use ARROW KEYS or MOUSE to move, SPACE or CLICK to fire!</p><button id="startBtn">START MISSION</button><small>Defeat all enemy waves — Stay alive!</small>`;
		const btn = document.getElementById('startBtn');
		btn.addEventListener('click', startGame, {once:true});
	}
	function gameOver(){
		state.running = false;
		const panel = document.getElementById('panel');
		panel.innerHTML = `<h1>MISSION FAILED</h1><h2>Score: ${state.score}</h2><button id="startBtn">RETRY MISSION</button><small style="margin-top:8px;display:block">Click to restart</small>`;
		document.getElementById('overlay').style.display = 'flex';
		document.getElementById('startBtn').addEventListener('click', ()=>{ setPanelDefault(); }, {once:true});
	}

	// Start
	setPanelDefault();
	requestAnimationFrame(loop);
	</script>
			o.connect(g); 
			g.connect(audioCtx.destination); 
			o.start(); 
			o.stop(audioCtx.currentTime + time); 
		}catch(e){} 
	}
	function playShoot(){ playBeep(1200,'square',0.04,0.15); playBeep(900,'square',0.03,0.1); }
	function playHit(){ playBeep(200,'square',0.05,0.2); playBeep(300,'square',0.04,0.15); }
	function playWaveUp(){ playBeep(1600,'square',0.08,0.12); playBeep(2000,'square',0.1,0.12); playBeep(1200,'square',0.06,0.1); }
	function playPowerUp(){ playBeep(600,'square',0.08,0.15); playBeep(900,'square',0.06,0.15); playBeep(1200,'square',0.08,0.15); }

	// Helpers
	function rand(min,max){return Math.random()*(max-min)+min}
	function clamp(v,a,b){return Math.max(a,Math.min(b,v))}

	// Input
	const keys = {};
	window.addEventListener('keydown', e=>{keys[e.code]=true; if(e.code==='Space'){e.preventDefault(); shoot()} });
	window.addEventListener('keyup', e=>{keys[e.code]=false});
	canvas.addEventListener('mousemove', e=>{
		const r = canvas.getBoundingClientRect();
		const mx = (e.clientX - r.left) * (canvas.width / r.width);
		const dpr = window.devicePixelRatio || 1;
		state.player.x = clamp(mx / dpr, state.player.w/2, W - state.player.w/2);
	});
	canvas.addEventListener('click', ()=>{ ensureAudio(); shoot(); });
	canvas.addEventListener('touchmove', e=>{ e.preventDefault(); const t=e.touches[0]; const r = canvas.getBoundingClientRect(); const mx = (t.clientX - r.left) * (canvas.width / r.width); const dpr = window.devicePixelRatio || 1; state.player.x = clamp(mx / dpr, state.player.w/2, W - state.player.w/2); }, {passive:false});
	canvas.addEventListener('touchstart', e=>{ e.preventDefault(); ensureAudio(); shoot(); }, {passive:false});

	// Shooting with cooldown
	function shoot(){
		if(!state.running) return;
		const now = performance.now();
		const minInterval = 1000 / state.fireRate;
		if(now - state.lastShot < minInterval) return;
		state.lastShot = now;
		
		if(state.multiShotActive) {
			// Triple shot
			state.bullets.push({x: state.player.x - 12, y: state.player.y-28, r:5, speed: 450});
			state.bullets.push({x: state.player.x, y: state.player.y-28, r:5, speed: 450});
			state.bullets.push({x: state.player.x + 12, y: state.player.y-28, r:5, speed: 450});
		} else {
			state.bullets.push({x: state.player.x, y: state.player.y-28, r:5, speed: 450}); // px/sec
		}
		playShoot();
	}

	// Particles
	function spawnParticles(x,y,color,count=10){
		for(let i=0;i<count;i++){
			state.particles.push({x,y,vx:rand(-160,160),vy:rand(-260,-60),life:rand(400,900),age:0,color});
		}
	}

	// Spawn frogs with different types - arcade wave style
	function spawnFrog(x, type){
		if(!x) x = rand(30, W-30);
		if(!type) type = 'normal';
		
		let size = rand(22, 36);
		let health = 1;
		let speedMult = 1;
		let color = '#2da44e';
		
		// Type-specific properties
		if(type === 'fast') {
			size = rand(16, 28);
			speedMult = 1.3;
			color = '#ff6b9d';
		} else if(type === 'tough') {
			size = rand(28, 42);
			health = 1; // Reduced for easier waves
			color = '#ffd700';
		} else if(type === 'heavy') {
			size = rand(32, 46);
			speedMult = 0.6;
			health = 1; // Reduced for easier waves
			color = '#8b4513';
		}
		
		const base = rand(35, 55) * speedMult;
		const speed = 0; // no vertical movement
		state.frogs.push({x, y:50, vx: 0, vy:speed, size, wobble:rand(0,Math.PI*2), type, health, maxHealth: health, color});
	}
	
	// Spawn arcade-style wave formations - larger groups in rows
	function spawnWaveFormation(){
		const wavePattern = state.wave % 5;
		
		if(wavePattern === 0) {
			// Two rows - 3 frogs each - mixed types
			spawnFrogRow(2, 3, 50, true);
		} else if(wavePattern === 1) {
			// Three rows - 4 frogs each - mixed types
			spawnFrogRow(3, 4, 50, true);
		} else if(wavePattern === 2) {
			// Two rows - 5 frogs each - mixed types
			spawnFrogRow(2, 5, 50, true);
		} else if(wavePattern === 3) {
			// Three rows - varied - mixed types
			spawnFrogRow(3, 4, 45, true);
		} else {
			// Three rows - mixed types
			spawnFrogRow(3, 5, 50, true);
		}
	}
	
	// Helper function to spawn a row of frogs
	function spawnFrogRow(numRows, frogsPerRow, rowSpacing, mixedTypes = false){
		const startY = 40;
		
		for(let row = 0; row < numRows; row++) {
			const yPos = startY + row * rowSpacing;
			const totalWidth = frogsPerRow * 55;
			const startX = (W - totalWidth) / 2;
			
			for(let col = 0; col < frogsPerRow; col++) {
				const xPos = startX + col * 55 + 25;
				let type = 'normal';
				if(mixedTypes) {
					if(Math.random() < 0.2) type = 'fast';
					if(Math.random() < 0.15) type = 'tough';
				}
				state.frogs.push(createFrog(xPos, yPos, type));
			}
		}
	}
	
	// Helper to create a frog object
	function createFrog(x, y, type){
		if(!type) type = 'normal';
		
		let size = rand(20, 32);
		let health = 1;
		let color = '#2da44e';
		
		// Type-specific properties
		if(type === 'fast') {
			size = rand(16, 26);
			color = '#ff6b9d';
		} else if(type === 'tough') {
			size = rand(24, 36);
			color = '#ffd700';
		} else if(type === 'heavy') {
			size = rand(28, 38);
			color = '#8b4513';
		}
		
		return {x, y, vx: 0, vy: 0, size, wobble: 0, type, health, maxHealth: health, color, shootTimer: rand(1000, 2500)};
	}
	
	// Difficulty: advance waves
	function advanceWave(){
		state.wave += 1;
		state.waveTimer = 0;
		// Gradually decrease spawn interval but cap it at 500ms to avoid overwhelming the game
		state.spawnInterval = Math.max(500, state.spawnInterval - 80);
		playWaveUp();
		
		// Spawn boss every 5 waves
		if(state.wave % 5 === 0) {
			state.bossFrog = {
				x: W/2,
				y: -80,
				vx: 0,
				vy: 35,
				size: 60,
				wobble: 0,
				type: 'boss',
				health: 10,
				maxHealth: 10,
				color: '#ff4444',
				pattern: 0,
				patternTimer: 0
			};
		}
	}

	// Spawn power-ups
	function spawnPowerUp(x, y){
		const types = ['rapidFire', 'shield', 'multiShot'];
		const type = types[Math.floor(Math.random() * types.length)];
		state.powerups.push({x, y, vx: rand(-40, 40), vy: -80, type, size: 16, rotation: 0});
	}
	
	// Apply power-up effect
	function applyPowerUp(powerup){
		playPowerUp();
		if(powerup.type === 'rapidFire') {
			state.rapidFireActive = true;
			state.rapidFireTimer = 6000; // 6 seconds
			state.fireRate = 18;
		} else if(powerup.type === 'shield') {
			state.lives = Math.min(state.lives + 1, 6);
			state.shieldActive = true;
			document.getElementById('lives').textContent = state.lives;
		} else if(powerup.type === 'multiShot') {
			state.multiShotActive = true;
			state.multiShotTimer = 8000; // 8 seconds
		}
	}

	// Update (dt in ms)
	function update(dt){
		const dtSec = dt/1000;
		if(!state.running) return;
		// Check if wave is cleared (all frogs and boss defeated)
		if(state.frogs.length === 0 && !state.bossFrog && state.wave > 0) {
			advanceWave();
		}

		// Update power-up timers
		if(state.rapidFireActive) {
			state.rapidFireTimer -= dt;
			if(state.rapidFireTimer <= 0) {
				state.rapidFireActive = false;
				state.fireRate = state.originalFireRate;
			}
		}
		if(state.multiShotActive) {
			state.multiShotTimer -= dt;
			if(state.multiShotTimer <= 0) {
				state.multiShotActive = false;
			}
		}

		// Update boss frog
		if(state.bossFrog) {
			state.bossFrog.y += state.bossFrog.vy * dtSec;
			state.bossFrog.wobble += dtSec * 1.5;
			state.bossFrog.vx = Math.sin(state.bossFrog.wobble) * 60;
			state.bossFrog.x += state.bossFrog.vx * dtSec;
			state.bossFrog.x = clamp(state.bossFrog.x, state.bossFrog.size/2, W - state.bossFrog.size/2);
			
			// Boss collision with player
			if(state.bossFrog.y + state.bossFrog.size/2 > state.player.y - 6){
				spawnParticles(state.bossFrog.x, state.player.y, '#ff6b6b', 30);
				state.bossFrog = null;
				state.lives -= 2;
				document.getElementById('lives').textContent = state.lives;
				if(state.lives <= 0) gameOver();
			}
			
			// Boss bullet collisions
			for(let j=state.bullets.length-1;j>=0;j--){
				const b = state.bullets[j];
				const dx = b.x - state.bossFrog.x, dy = b.y - state.bossFrog.y;
				if(dx*dx + dy*dy < (b.r + state.bossFrog.size/2)*(b.r + state.bossFrog.size/2)){
					state.bullets.splice(j,1);
					state.bossFrog.health -= 1;
					spawnParticles(b.x, b.y, '#ff4444', 8);
					if(state.bossFrog.health <= 0) {
						state.score += 500;
						document.getElementById('score').textContent = state.score;
						spawnParticles(state.bossFrog.x, state.bossFrog.y, '#ffff00', 40);
						playHit();
						// Boss drops power-up
						for(let i = 0; i < 3; i++) {
							spawnPowerUp(state.bossFrog.x + rand(-40, 40), state.bossFrog.y);
						}
						state.bossFrog = null;
					}
				}
			}
		}

		// player movement by keys
		if(keys['ArrowLeft']||keys['KeyA']) state.player.x -= state.player.speed * dtSec;
		if(keys['ArrowRight']||keys['KeyD']) state.player.x += state.player.speed * dtSec;
		state.player.x = clamp(state.player.x, state.player.w/2, W - state.player.w/2);

		// bullets
		for(let i=state.bullets.length-1;i>=0;i--){
			const b = state.bullets[i];
			b.y -= b.speed * dtSec;
			if(b.y < -20) state.bullets.splice(i,1);
		}

		// enemy bullets
		for(let i=state.enemyBullets.length-1;i>=0;i--){
			const b = state.enemyBullets[i];
			b.y += b.speed * dtSec;
			if(b.y > H) {
				state.enemyBullets.splice(i,1);
				continue;
			}
			
			// Check collision with player
			const dx = b.x - state.player.x;
			const dy = b.y - state.player.y;
			if(dx*dx + dy*dy < (b.r + state.player.w/2)*(b.r + state.player.w/2)){
				state.enemyBullets.splice(i,1);
				state.lives -= 1;
				document.getElementById('lives').textContent = state.lives;
				spawnParticles(b.x, b.y, '#ff6b6b', 10);
				if(state.lives <= 0) gameOver();
			}
		}

		// power-ups
		for(let i=state.powerups.length-1;i>=0;i--){
			const p = state.powerups[i];
			p.vy += 500 * dtSec; // gravity
			p.x += p.vx * dtSec;
			p.y += p.vy * dtSec;
			p.rotation += dtSec * 4;
			
			// Off-screen
			if(p.y > H) {
				state.powerups.splice(i,1);
				continue;
			}
			
			// Collect power-up
			const dx = p.x - state.player.x;
			const dy = p.y - state.player.y;
			if(dx*dx + dy*dy < (p.size + state.player.w/2)*(p.size + state.player.w/2)){
				applyPowerUp(p);
				spawnParticles(p.x, p.y, '#2dd4bf', 12);
				state.powerups.splice(i,1);
			}
		}

		// frogs - Space Invaders style movement
		state.frogMoveCounter += dt;
		const moveSpeed = 100; // pixels per move interval
		const moveInterval = 500; // milliseconds between moves
		
		if(state.frogMoveCounter > moveInterval) {
			state.frogMoveCounter = 0;
			let hitEdge = false;
			
			// Move all frogs horizontally
			for(let f of state.frogs) {
				f.x += state.frogDirection * moveSpeed;
				// Check if hit edge
				if(f.x - f.size/2 <= 30 || f.x + f.size/2 >= W - 30) {
					hitEdge = true;
				}
			}
			
			// If hit edge, change direction and move down
			if(hitEdge) {
				state.frogDirection *= -1;
				// Frogs stay at same vertical position
			}
		}
		
		// Regular vertical movement
		for(let i=state.frogs.length-1;i>=0;i--){
			const f = state.frogs[i];
			// No vertical movement - frogs stay in place
			// collide with player bottom
			if(f.y + f.size/2 > state.player.y - 6){
				spawnParticles(f.x, state.player.y, '#ff6b6b', 18);
				state.frogs.splice(i,1);
				state.lives -= 1;
				document.getElementById('lives').textContent = state.lives;
				if(state.lives <= 0) gameOver();
				continue;
			}
			// bullets collisions
			for(let j=state.bullets.length-1;j>=0;j--){
				const b = state.bullets[j];
				const dx = b.x - f.x, dy = b.y - f.y;
				if(dx*dx + dy*dy < (b.r + f.size/2)*(b.r + f.size/2)){
					// hit
					state.bullets.splice(j,1);
					f.health -= 1;
					
					if(f.health <= 0) {
						state.frogs.splice(i,1);
						state.score += Math.round(10 + f.size + state.wave*2 + (f.maxHealth-1)*15);
						document.getElementById('score').textContent = state.score;
						spawnParticles(f.x, f.y, f.color, 18);
						playHit();
						// Chance to spawn power-up
						if(Math.random() < 0.15) {
							spawnPowerUp(f.x, f.y);
						}
					} else {
						// Damage particle
						spawnParticles(f.x, f.y, f.color, 6);
					}
					break;
				}
			}
		}

		// particles
		for(let i=state.particles.length-1;i>=0;i--){
			const p = state.particles[i];
			p.age += dt;
			p.vy += 700 * dtSec; // gravity
			p.x += p.vx * dtSec;
			p.y += p.vy * dtSec;
			if(p.age >= p.life) state.particles.splice(i,1);
		}

		// spawn logic - arcade wave formations with breaks
		state.spawnWaveTimer += dt;
		
		// Toggle between spawn active and break periods
		if(state.spawnWaveActive) {
			// Currently spawning - check if spawn wave should end
			if(state.spawnWaveTimer > state.spawnWaveDuration) {
				state.spawnWaveTimer = 0;
				state.spawnWaveActive = false; // Start break
			}
		} else {
			// Currently in break - check if break should end
			if(state.spawnWaveTimer > state.spawnBreakDuration) {
				state.spawnWaveTimer = 0;
				state.spawnWaveActive = true; // Resume spawning
			}
		}
		
		// Only spawn during active spawn period
		if(state.spawnWaveActive) {
			state.spawnTimer += dt;
			// Cap spawn factor to prevent excessive spawning at high waves
			const spawnFactor = Math.min(1.3, 0.85 + (state.wave-1)*0.02);
			if(state.spawnTimer > state.spawnInterval * spawnFactor){
				state.spawnTimer = 0;
				// spawn a formation instead of single frogs
				spawnWaveFormation();
			}
		}
		
		// Enemy shooting
		for(let i=state.frogs.length-1;i>=0;i--){
			const f = state.frogs[i];
			f.shootTimer -= dt;
			if(f.shootTimer <= 0) {
				// Enemy shoots randomly
				if(Math.random() < 0.4) {
					state.enemyBullets.push({x: f.x, y: f.y + f.size/2, r: 4, speed: 300});
				}
				f.shootTimer = rand(1500, 3000); // Reload time
			}
		}
	}

	// Draw helpers
	function drawPlayer(){
		const p = state.player;
		ctx.save();
		ctx.translate(p.x, p.y);
		
		// Pixel art lily pad
		ctx.fillStyle = '#2a8f4f';
		ctx.fillRect(-20, 0, 40, 8);
		ctx.fillStyle = '#1a5f2f';
		ctx.fillRect(-18, 2, 36, 4);
		ctx.fillStyle = '#3aaf5f';
		ctx.fillRect(-16, 4, 32, 2);
		
		// Pixel art barrel/shooter
		ctx.fillStyle = '#0d3a1a';
		ctx.fillRect(-6, -20, 12, 14);
		ctx.fillStyle = '#1a5a2a';
		ctx.fillRect(-4, -18, 8, 10);
		ctx.fillStyle = '#2dd4bf';
		ctx.fillRect(-2, -16, 4, 6);
		
		ctx.restore();
	}

	function drawBullet(b){
		ctx.save();
		ctx.fillStyle = '#ffff00';
		ctx.fillRect(b.x - 3, b.y - 6, 6, 12);
		ctx.fillStyle = '#ffcc00';
		ctx.fillRect(b.x - 2, b.y - 4, 4, 8);
		ctx.restore();
	}
	
	function drawEnemyBullet(b){
		ctx.save();
		ctx.fillStyle = '#ff6b6b';
		ctx.fillRect(b.x - 3, b.y - 6, 6, 12);
		ctx.fillStyle = '#ff3333';
		ctx.fillRect(b.x - 2, b.y - 4, 4, 8);
		ctx.restore();
	}

	function drawFrog(f){
		ctx.save();
		ctx.translate(f.x, f.y);
		
		// Pixel art frog body - blocky design
		const colors = {
			'normal': ['#2da44e', '#1a8f4e'],
			'fast': ['#ff6b9d', '#d63a6a'],
			'tough': ['#ffd700', '#ccaa00'],
			'heavy': ['#8b4513', '#6b3410']
		};
		
		const [mainColor, darkColor] = colors[f.type] || colors['normal'];
		const w = f.size / 2;
		
		// Body segments
		ctx.fillStyle = mainColor;
		ctx.fillRect(-w, -f.size*0.15, w*2, f.size*0.25);
		ctx.fillStyle = darkColor;
		ctx.fillRect(-w + 2, -f.size*0.12, w*2 - 4, 3);
		
		// Head
		ctx.fillStyle = mainColor;
		ctx.fillRect(-w*0.8, -f.size*0.35, w*1.6, f.size*0.25);
		ctx.fillStyle = darkColor;
		ctx.fillRect(-w*0.7, -f.size*0.3, w*1.4, 2);
		
		// Left eye
		ctx.fillStyle = '#fff';
		ctx.fillRect(-w*0.5, -f.size*0.4, w*0.4, w*0.4);
		ctx.fillStyle = '#2dd4bf';
		ctx.fillRect(-w*0.45, -f.size*0.35, w*0.3, w*0.3);
		ctx.fillStyle = '#000';
		ctx.fillRect(-w*0.4, -f.size*0.3, w*0.2, w*0.2);
		
		// Right eye
		ctx.fillStyle = '#fff';
		ctx.fillRect(w*0.1, -f.size*0.4, w*0.4, w*0.4);
		ctx.fillStyle = '#2dd4bf';
		ctx.fillRect(w*0.15, -f.size*0.35, w*0.3, w*0.3);
		ctx.fillStyle = '#000';
		ctx.fillRect(w*0.2, -f.size*0.3, w*0.2, w*0.2);
		
		// Health indicator
		if(f.health > 1) {
			ctx.fillStyle = '#ffff00';
			ctx.font = 'bold ' + Math.max(10, f.size*0.35) + 'px Arial';
			ctx.textAlign = 'center';
			ctx.fillText(f.health, 0, f.size*0.2);
		}
		
		ctx.restore();
	}
	
	// Utility function to shade colors
	function shadeColor(col, percent) {
		let num = parseInt(col.replace("#",""), 16), amt = Math.round(2.55 * percent), R = (num >> 16) + amt, G = (num >> 8 & 0x00FF) + amt, B = (num & 0x0000FF) + amt;
		return "#" + (0x1000000 + (R<255?R<1?0:R:255)*0x10000 + (G<255?G<1?0:G:255)*0x100 + (B<255?B<1?0:B:255)).toString(16).slice(1);
	}
	
	// Draw boss frog - larger pixel art enemy
	function drawBossFrog(f){
		ctx.save();
		ctx.translate(f.x, f.y);
		
		const w = f.size / 2;
		
		// Main body segments
		ctx.fillStyle = '#ff4444';
		ctx.fillRect(-w*1.2, -f.size*0.2, w*2.4, f.size*0.35);
		ctx.fillStyle = '#cc1111';
		ctx.fillRect(-w*1.1, -f.size*0.15, w*2.2, 4);
		
		// Head
		ctx.fillStyle = '#ff4444';
		ctx.fillRect(-w, -f.size*0.5, w*2, f.size*0.35);
		ctx.fillStyle = '#cc1111';
		ctx.fillRect(-w+2, -f.size*0.45, w*2-4, 3);
		
		// Eyes - larger
		ctx.fillStyle = '#ffff00';
		ctx.fillRect(-w*0.6, -f.size*0.55, w*0.6, w*0.5);
		ctx.fillStyle = '#ffaa00';
		ctx.fillRect(-w*0.5, -f.size*0.5, w*0.4, w*0.4);
		ctx.fillStyle = '#000';
		ctx.fillRect(-w*0.4, -f.size*0.45, w*0.25, w*0.25);
		
		ctx.fillStyle = '#ffff00';
		ctx.fillRect(w*0, -f.size*0.55, w*0.6, w*0.5);
		ctx.fillStyle = '#ffaa00';
		ctx.fillRect(w*0.1, -f.size*0.5, w*0.4, w*0.4);
		ctx.fillStyle = '#000';
		ctx.fillRect(w*0.15, -f.size*0.45, w*0.25, w*0.25);
		
		// Health bar
		const barWidth = w*2;
		const barHeight = 8;
		ctx.fillStyle = '#000';
		ctx.fillRect(-w, f.size*0.4, barWidth, barHeight);
		ctx.strokeStyle = '#ffff00';
		ctx.lineWidth = 2;
		ctx.strokeRect(-w, f.size*0.4, barWidth, barHeight);
		
		// Health fill
		const healthPercent = f.health / f.maxHealth;
		ctx.fillStyle = '#00ff00';
		ctx.fillRect(-w + 2, f.size*0.4 + 2, (barWidth - 4) * healthPercent, barHeight - 4);
		
		ctx.restore();
	}
	
	// Draw power-ups with pixel art
	function drawPowerUp(p) {
		ctx.save();
		ctx.translate(p.x, p.y);
		ctx.rotate(p.rotation);
		
		const colors = {
			rapidFire: '#ff9500',
			shield: '#2dd4bf',
			multiShot: '#c084fc'
		};
		
		const color = colors[p.type] || '#fff';
		ctx.fillStyle = color;
		
		// Pixel art power-up symbols
		if(p.type === 'rapidFire') {
			// Lightning bolt
			ctx.fillRect(-3, -p.size, 6, 6);
			ctx.fillRect(2, -p.size + 6, 6, 6);
			ctx.fillRect(-3, -p.size + 12, 6, 6);
		} else if(p.type === 'shield') {
			// Shield
			ctx.fillRect(-p.size, -p.size, p.size*2, p.size*1.5);
			ctx.fillStyle = color;
			ctx.globalAlpha = 0.7;
			ctx.fillRect(-p.size + 2, -p.size + 2, p.size*2 - 4, p.size*1.5 - 4);
		} else if(p.type === 'multiShot') {
			// Triple bullets
			ctx.fillRect(-6, -p.size, 4, 8);
			ctx.fillRect(1, -p.size, 4, 8);
			ctx.fillRect(8, -p.size, 4, 8);
		}
		
		ctx.restore();
	}

	function drawParticle(p){
		const t = 1 - (p.age / p.life);
		ctx.fillStyle = p.color;
		ctx.globalAlpha = Math.max(0, t);
		ctx.fillRect(p.x-2, p.y-2, 4, 4);
		ctx.globalAlpha = 1;
	}

	function render(){
		// Clear with arcade-style background
		const bgGrad = ctx.createLinearGradient(0, 0, 0, H);
		bgGrad.addColorStop(0, '#1a1a2a');
		bgGrad.addColorStop(0.5, '#0f2a1a');
		bgGrad.addColorStop(1, '#0a1a0f');
		ctx.fillStyle = bgGrad;
		ctx.fillRect(0, 0, W, H);
		
		// Scanline effect for retro arcade feel
		ctx.strokeStyle = 'rgba(255, 255, 255, 0.03)';
		ctx.lineWidth = 1;
		for(let y = 0; y < H; y += 2) {
			ctx.beginPath();
			ctx.moveTo(0, y);
			ctx.lineTo(W, y);
			ctx.stroke();
		}
		
		// frogs
		for(const f of state.frogs) drawFrog(f);
		
		// boss frog
		if(state.bossFrog) drawBossFrog(state.bossFrog);
		
		// bullets
		for(const b of state.bullets) drawBullet(b);
		// enemy bullets
		for(const b of state.enemyBullets) drawEnemyBullet(b);
		// power-ups
		for(const p of state.powerups) drawPowerUp(p);
		// particles
		for(const p of state.particles) drawParticle(p);
		// player
		drawPlayer();
		
		// Power-up status indicators
		let statusX = W - 200;
		if(state.rapidFireActive) {
			ctx.fillStyle = '#ff9500';
			ctx.strokeStyle = '#ffaa00';
			ctx.lineWidth = 2;
			ctx.fillRect(statusX, 12, 180, 32);
			ctx.strokeRect(statusX, 12, 180, 32);
			ctx.fillStyle = '#000';
			ctx.font = 'bold 12px Arial';
			ctx.fillText('RAPID FIRE ' + Math.ceil(state.rapidFireTimer/1000) + 's', statusX+8, 35);
			statusX -= 190;
		}
		if(state.multiShotActive) {
			ctx.fillStyle = '#c084fc';
			ctx.strokeStyle = '#d0a4ff';
			ctx.lineWidth = 2;
			ctx.fillRect(statusX, 12, 180, 32);
			ctx.strokeRect(statusX, 12, 180, 32);
			ctx.fillStyle = '#000';
			ctx.font = 'bold 12px Arial';
			ctx.fillText('MULTI-SHOT ' + Math.ceil(state.multiShotTimer/1000) + 's', statusX+8, 35);
		}
		
		// Boss indicator
		if(state.bossFrog) {
			ctx.fillStyle = '#ff4444';
			ctx.strokeStyle = '#ffaa00';
			ctx.lineWidth = 3;
			ctx.fillRect(W/2 - 100, 12, 200, 40);
			ctx.strokeRect(W/2 - 100, 12, 200, 40);
			ctx.fillStyle = '#000';
			ctx.font = 'bold 14px Arial';
			ctx.textAlign = 'center';
			ctx.fillText('BOSS FROG - HP: ' + state.bossFrog.health + '/' + state.bossFrog.maxHealth, W/2, 38);
			ctx.textAlign = 'left';
		}
		
		// Spawn wave indicator
		if(!state.spawnWaveActive) {
			ctx.fillStyle = '#2dd4bf';
			ctx.strokeStyle = '#00ffff';
			ctx.lineWidth = 2;
			ctx.fillRect(W/2 - 120, 60, 240, 30);
			ctx.strokeRect(W/2 - 120, 60, 240, 30);
			ctx.fillStyle = '#000';
			ctx.font = 'bold 12px Arial';
			ctx.textAlign = 'center';
			ctx.fillText('WAVE INCOMING IN ' + Math.ceil((state.spawnBreakDuration - state.spawnWaveTimer)/1000) + 's', W/2, 80);
			ctx.textAlign = 'left';
		}
		
		// HUD: wave - arcade style
		ctx.fillStyle = '#2dd4bf';
		ctx.strokeStyle = '#00ffff';
		ctx.lineWidth = 2;
		ctx.fillRect(12, H-50, 140, 38);
		ctx.strokeRect(12, H-50, 140, 38);
		ctx.fillStyle = '#000';
		ctx.font = 'bold 16px Arial';
		ctx.fillText('WAVE ' + state.wave, 24, H-26);
	}

	// Game loop
	let last = performance.now();
	function loop(t){
		const dt = t - last; last = t;
		update(dt);
		render();
		requestAnimationFrame(loop);
	}

	// Resize handling with DPR support
	function fitCanvas(){
		const ratio = 900/600;
		const maxW = Math.min(window.innerWidth-20, 1100);
		const cssW = Math.max(380, Math.min(maxW, window.innerWidth-40));
		const cssH = Math.round(cssW / ratio);
		const dpr = Math.max(1, window.devicePixelRatio || 1);
		canvas.style.width = cssW + 'px';
		canvas.style.height = cssH + 'px';
		canvas.width = Math.round(cssW * dpr);
		canvas.height = Math.round(cssH * dpr);
		ctx.setTransform(dpr,0,0,dpr,0,0);
		W = cssW; H = cssH;
		state.player.y = H - 60;
	}
	window.addEventListener('resize', fitCanvas);
	fitCanvas();

	// Game control
	function startGame(){
		ensureAudio();
		state.running = true;
		state.score = 0; state.lives = 3;
		state.bullets = []; state.enemyBullets = []; state.frogs = []; state.particles = []; state.powerups = [];
		state.spawnTimer = 0; state.spawnInterval = 7000; state.lastShot = 0; state.wave = 1; state.waveTimer = 0;
		state.rapidFireActive = false; state.rapidFireTimer = 0;
		state.multiShotActive = false; state.multiShotTimer = 0;
		state.fireRate = state.originalFireRate;
		state.spawnWaveActive = true;
		state.spawnWaveTimer = 0;
		state.frogDirection = 1;
		state.frogMoveCounter = 0;
		document.getElementById('score').textContent = state.score;
		document.getElementById('lives').textContent = state.lives;
		document.getElementById('overlay').style.display = 'none';
	}
	function setPanelDefault(){
		const panel = document.getElementById('panel');
		panel.innerHTML = `<h1 style="margin:0 0 8px">Frog Shooter</h1><p style="margin:0 0 12px">Shoot the invading frogs! Use mouse or arrow keys to move, click or press <strong>Space</strong> to shoot.</p><button id="startBtn">Start Game</button><small>Frogs spawn and hop down — protect your pad!</small>`;
		const btn = document.getElementById('startBtn');
		btn.addEventListener('click', startGame, {once:true});
	}
	function gameOver(){
		state.running = false;
		const panel = document.getElementById('panel');
		panel.innerHTML = `<h1 style="margin:0 0 8px">Game Over</h1><p style="margin:0 0 12px">Score: ${state.score}</p><button id="startBtn">Play Again</button><small style="margin-top:8px;display:block">Click to restart</small>`;
		document.getElementById('overlay').style.display = 'flex';
		document.getElementById('startBtn').addEventListener('click', ()=>{ setPanelDefault(); }, {once:true});
	}

	// Start button hookup
	setPanelDefault();

	// initialize loop
	requestAnimationFrame(loop);
	</script>
</body>
</html>
